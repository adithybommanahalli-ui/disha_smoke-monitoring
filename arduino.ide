#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <WiFiClientSecure.h>

// ================= CONFIGURATION =================
const char* GOOGLE_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzhWXahTqmv-MANVuLSM4ij7qNhv5GlfBsZy8CpQK8YBX9_RhbxCe9pvULsZFoqZo3aJA/exec";

#define MQ2_SENSOR_PIN A0
#define BUZZER_PIN D5

const int BASE_THRESHOLD = 200;
const int HYSTERESIS = 1;  // Prevent flickering at threshold

// WiFi Networks (Will auto-connect to strongest signal)
struct WiFiNetwork {
  const char* ssid;
  const char* password;
  int priority;  // Higher = preferred if signal equal
};

WiFiNetwork networks[] = {
  {"Adityab", "Aditya1167", 100},
  {"vivo 1820", "bakasura200", 90},
};
const int NETWORK_COUNT = sizeof(networks) / sizeof(networks[0]);

// ================= STATE VARIABLES =================
int smokeValue = 0;
int lastLoggedValue = -1;
bool smokeDetected = false;          // Current physical smoke state (updated every loop)
bool lastSmokeStatus = false;        // Last state that was successfully sent
bool buzzerEnabled = true;
bool systemOnline = false;
String deviceId = "";
String currentSSID = "";
String lastError = "";

// Timing
unsigned long lastSendTime = 0;
unsigned long lastCommandCheck = 0;
unsigned long lastSuccessfulSend = 0;
unsigned long wifiReconnectTime = 0;

// Intervals
const unsigned long MIN_SEND_INTERVAL = 3000;      // 3 sec between events
const unsigned long COMMAND_INTERVAL = 5000;       // 5 sec command check
const unsigned long HEARTBEAT_INTERVAL = 25000;    // 25 sec heartbeat (keep alive)
const unsigned long AUTO_RESET_DELAY = 30000;      // 30 sec auto-reset buzzer
const unsigned long OFFLINE_TIMEOUT = 35000;       // Mark offline if no send for 35 sec

// Event tracking
String lastEventReason = "BOOT";
int eventCounter = 0;

// New: pending event that should be sent as soon as WiFi is available
String pendingEventReason = "";

// ================= SETUP =================
void setup() {
  Serial.begin(115200);
  delay(1000);
  
  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(BUZZER_PIN, LOW);
  
  
  WiFi.persistent(false);
  WiFi.setAutoReconnect(false);
  
  deviceId = String(ESP.getChipId(), HEX);
  deviceId.toUpperCase();
  Serial.printf("[INIT] Device ID: %s\n", deviceId.c_str());
  Serial.printf("[INIT] Threshold: %d\n", BASE_THRESHOLD);
  Serial.printf("[INIT] Networks configured: %d\n", NETWORK_COUNT);
  
  connectToBestWiFi();
  
  Serial.println("========================================\n");
  
  // Initial data send
  if (systemOnline) {
    sendDataToGoogle("SYSTEM_BOOT", true);
  }
}

// ================= MAIN LOOP =================
void loop() {
  unsigned long now = millis();
  
  // 1. Always read sensor and update smoke state (buzzer controlled here)
  smokeValue = readSmokeSensor();
  updateSmokeState(now);
  
  // 2. WiFi management (attempt reconnect if needed)
  if (WiFi.status() != WL_CONNECTED) {
    if (systemOnline) {
      systemOnline = false;
      Serial.println("[WIFI] ‚ö†Ô∏è CONNECTION LOST");
    }
    if (now - wifiReconnectTime > 10000) {  // Try reconnect every 10 sec
      wifiReconnectTime = now;
      connectToBestWiFi();
    }
  } else {
    if (!systemOnline) {
      systemOnline = true;
      currentSSID = WiFi.SSID();
      Serial.printf("[WIFI] ‚úÖ RECONNECTED: %s (RSSI: %d dBm)\n", 
                    currentSSID.c_str(), WiFi.RSSI());
    }
  }
  
  // 3. WiFi‚Äëdependent tasks (only when online)
  if (systemOnline) {
    processEventSending(now);   // Check for events that need to be sent
    checkCommands(now);         // Retrieve commands from dashboard
    
    // Heartbeat (keep‚Äëalive)
    if (now - lastSuccessfulSend > HEARTBEAT_INTERVAL) {
      Serial.println("[HEARTBEAT] Sending keep-alive...");
      if (sendDataToGoogle("HEARTBEAT", false)) {
        lastSuccessfulSend = now;
      }
    }
  }
  
  delay(50);  // Small delay for stability
}

// ================= SENSOR READING =================
int readSmokeSensor() {
  // Take 3 samples and average
  int sum = 0;
  for (int i = 0; i < 3; i++) {
    sum += analogRead(MQ2_SENSOR_PIN);
    delay(5);
  }
  int avg = sum / 3;
  
  static unsigned long lastPrint = 0;
  if (millis() - lastPrint > 2000) {
    Serial.printf("[SENSOR] Value: %d | Status: %s | Buzzer: %s\n", 
                  avg, 
                  smokeDetected ? "SMOKE" : "CLEAR",
                  buzzerEnabled ? "ON" : "MUTED");
    lastPrint = millis();
  }
  return avg;
}

// ================= UPDATE SMOKE STATE AND BUZZER (ALWAYS RUNS) =================
void updateSmokeState(unsigned long now) {
  // Apply hysteresis to prevent flickering
  bool currentSmoke;
  if (smokeDetected) {
    currentSmoke = smokeValue > (BASE_THRESHOLD - HYSTERESIS);
  } else {
    currentSmoke = smokeValue > (BASE_THRESHOLD + HYSTERESIS);
  }

  // Update the physical smoke flag
  smokeDetected = currentSmoke;

  // Control buzzer ‚Äì independent of WiFi
  if (smokeDetected && buzzerEnabled) {
    digitalWrite(BUZZER_PIN, HIGH);
  } else {
    digitalWrite(BUZZER_PIN, LOW);
  }

  // Auto‚Äëreset buzzer after smoke clears (if it was muted during smoke)
  static unsigned long smokeClearedTime = 0;
  if (!smokeDetected && !buzzerEnabled) {
    if (smokeClearedTime == 0) smokeClearedTime = now;
    if (now - smokeClearedTime > AUTO_RESET_DELAY) {
      buzzerEnabled = true;
      smokeClearedTime = 0;
      Serial.println("üîî AUTO-RESET: Buzzer re-enabled");
      // Mark that we need to send an AUTO_RESET event (will be sent when online)
      pendingEventReason = "AUTO_RESET";
    }
  } else {
    smokeClearedTime = 0;
  }
}

// ================= PROCESS EVENT SENDING (ONLINE ONLY) =================
void processEventSending(unsigned long now) {
  String reason = "";
  bool shouldSend = false;
  bool shouldLog = true;   // Always log real events (not heartbeats)
  
  // 1. Smoke start or end (compare with last successfully sent state)
  if (smokeDetected != lastSmokeStatus) {
    shouldSend = true;
    reason = smokeDetected ? "SMOKE_START" : "SMOKE_END";
    Serial.printf("\nüö® EVENT: %s\n", reason.c_str());
  }
  // 2. Significant value change during smoke (at least 40 units)
  else if (smokeDetected && abs(smokeValue - lastLoggedValue) >= 40 &&
           (now - lastSendTime > MIN_SEND_INTERVAL)) {
    shouldSend = true;
    reason = "VALUE_CHANGE";
    Serial.printf("\nüìà EVENT: Value change %d -> %d\n", lastLoggedValue, smokeValue);
  }
  // 3. Pending auto‚Äëreset event (from updateSmokeState)
  else if (pendingEventReason != "") {
    shouldSend = true;
    reason = pendingEventReason;
    pendingEventReason = "";   // Clear after taking
  }
  
  if (shouldSend) {
    if (sendDataToGoogle(reason, shouldLog)) {
      lastSendTime = now;
      lastSuccessfulSend = now;
      lastLoggedValue = smokeValue;
      lastSmokeStatus = smokeDetected;   // Update sent status only on success
      eventCounter++;
      Serial.printf("[TX] ‚úÖ Success: %s (Event #%d)\n", reason.c_str(), eventCounter);
    } else {
      Serial.printf("[TX] ‚ùå Failed: %s\n", reason.c_str());
      // If send fails, we do NOT update lastSmokeStatus or lastLoggedValue,
      // so the event will be retried on the next online loop.
    }
  }
}

// ================= WIFI MANAGEMENT (RSSI-based) =================
void connectToBestWiFi() {
  Serial.println("\n[WIFI] Scanning for best network...");
  WiFi.mode(WIFI_STA);
  WiFi.disconnect();
  delay(100);
  
  // Scan networks
  int n = WiFi.scanNetworks();
  if (n == 0) {
    Serial.println("[WIFI] ‚ùå No networks found");
    return;
  }
  
  Serial.printf("[WIFI] Found %d networks\n", n);
  
  // Find best configured network by RSSI
  int bestIndex = -1;
  int bestRSSI = -1000;
  int bestPriority = -1;
  
  for (int i = 0; i < n; i++) {
    String ssid = WiFi.SSID(i);
    int rssi = WiFi.RSSI(i);
    
    Serial.printf("       [%d] %s (%d dBm)\n", i, ssid.c_str(), rssi);
    
    // Check if this SSID is in our configured list
    for (int j = 0; j < NETWORK_COUNT; j++) {
      if (ssid.equals(networks[j].ssid)) {
        // Prefer higher RSSI, but consider priority if close
        if (rssi > bestRSSI + 5 || (rssi > bestRSSI - 5 && networks[j].priority > bestPriority)) {
          bestRSSI = rssi;
          bestIndex = j;
          bestPriority = networks[j].priority;
        }
      }
    }
  }
  
  if (bestIndex >= 0) {
    Serial.printf("[WIFI] Connecting to: %s (%d dBm, Priority: %d)...\n", 
                  networks[bestIndex].ssid, bestRSSI, bestPriority);
    
    WiFi.begin(networks[bestIndex].ssid, networks[bestIndex].password);
    
    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < 30) {
      delay(500);
      Serial.print(".");
      attempts++;
    }
    
    if (WiFi.status() == WL_CONNECTED) {
      currentSSID = networks[bestIndex].ssid;
      systemOnline = true;
      Serial.printf("\n[WIFI] ‚úÖ CONNECTED\n");
      Serial.printf("       IP: %s\n", WiFi.localIP().toString().c_str());
      Serial.printf("       RSSI: %d dBm\n", WiFi.RSSI());
      return;
    } else {
      Serial.println("\n[WIFI] ‚ùå Connection failed");
    }
  } else {
    Serial.println("[WIFI] ‚ùå No configured networks found");
  }
  
  systemOnline = false;
  currentSSID = "";
}

// ================= COMMANDS FROM DASHBOARD =================
void checkCommands(unsigned long now) {
  if (now - lastCommandCheck < COMMAND_INTERVAL) return;
  lastCommandCheck = now;
  
  Serial.println("[CMD] Checking for commands...");
  
  WiFiClientSecure client;
  HTTPClient http;
  client.setInsecure();
  
  String url = String(GOOGLE_SCRIPT_URL);
  url += "?action=getCommand&device=" + deviceId;
  url += "&rssi=" + String(WiFi.RSSI());
  
  http.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS);
  http.begin(client, url);
  http.setTimeout(3000);
  
  int httpCode = http.GET();
  if (httpCode == 200) {
    String resp = http.getString();
    Serial.printf("[CMD] Response: %s\n", resp.c_str());
    
    // Parse JSON response
    if (resp.indexOf("\"buzzer\":\"0\"") >= 0 && buzzerEnabled) {
      buzzerEnabled = false;
      digitalWrite(BUZZER_PIN, LOW);
      Serial.println("[CMD] üîï Buzzer MUTED by dashboard");
      sendDataToGoogle("CMD_MUTE", true);
    }
    else if (resp.indexOf("\"buzzer\":\"1\"") >= 0 && !buzzerEnabled) {
      buzzerEnabled = true;
      Serial.println("[CMD] üîî Buzzer ENABLED by dashboard");
      sendDataToGoogle("CMD_ENABLE", true);
    }
    else if (resp.indexOf("\"ping\":\"1\"") >= 0) {
      Serial.println("[CMD] Ping received");
    }
  } else {
    Serial.printf("[CMD] ‚ùå HTTP Error: %d\n", httpCode);
  }
  http.end();
}

// ================= DATA TRANSMISSION =================
bool sendDataToGoogle(String reason, bool logToSheet) {
  WiFiClientSecure client;
  HTTPClient http;
  client.setInsecure();
  
  String url = String(GOOGLE_SCRIPT_URL);
  url += "?smoke_value=" + String(smokeValue);
  url += "&status=" + String(smokeDetected ? 1 : 0);
  url += "&wifi=" + urlEncode(currentSSID);
  url += "&device=" + deviceId;
  url += "&reason=" + urlEncode(reason);
  url += "&buzzer=" + String(buzzerEnabled ? 1 : 0);
  url += "&log=" + String(logToSheet ? "1" : "0");  // Tell GAS whether to log
  url += "&rssi=" + String(WiFi.RSSI());
  
  Serial.printf("[TX] Sending: %s (Log:%s) | Smoke:%d | ", 
                reason.c_str(), 
                logToSheet ? "YES" : "NO",
                smokeValue);
  
  http.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS);
  http.begin(client, url);
  http.setTimeout(5000);
  
  int httpCode = http.GET();
  String resp = http.getString();
  http.end();
  
  if (httpCode == 200) {
    Serial.println("OK");
    if (resp.indexOf("DUPLICATE") >= 0) {
      Serial.println("[TX] Duplicate prevented by server");
    }
    return true;
  } else {
    Serial.printf("FAIL(%d)\n", httpCode);
    return false;
  }
}

// ================= UTILITIES =================
String urlEncode(String str) {
  String out = "";
  for (unsigned int i = 0; i < str.length(); i++) {
    char c = str.charAt(i);
    if (c == ' ') out += "%20";
    else if (c == '&') out += "%26";
    else if (c == '=') out += "%3D";
    else if (c == '?') out += "%3F";
    else out += c;
  }
  return out;
}
